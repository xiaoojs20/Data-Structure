# Assignment_1

## 面试(Interview)

可以将应聘者看为`ListNode`，将应聘者围成的圈看成首尾相连的**双向循环列表**。

每个`ListNode`都有`id`, 以及前驱节点`pred`，和后继节点`succ`，值得注意的是一开始只有一个结点的时候，节点的`pred`和`succ`都是自身，这样才能形成循环列表。

`List`从左向右为逆时针。

`List`里面需要一个指针`last`来确定最后一个到达的人，并且从他开始顺时针（向右）输出列表。

`ListNode* insertAsSucc(ListNode *nowNode, int id)`函数，用来执行将新节点插入指定的点后继。

`void insert(int m, int id)`函数，用来执行从将新节点插入最后一个节点的后m个位置，只需要找到`Last`之后`m-1`个节点位置，然后执行`insertAsSucc`即可。

`void print()`实现了从`last`节点向前（逆时针）输出直到回到自己，这里用`do...while`很合适。

## 火车调度

题目描述与**栈混洗**相同，故应该写一个stack类，然后进行操作。

这里规定的栈拥有最大容量，我一开始写的时候无脑地感觉继承`vector`效率更高，但这样却好像变得更麻烦，既然给定了栈的最大容量，那么为什么不直接用数组实现法，课件上也有相应的内容。

接下来就是判断能否栈混洗成功，栈中维护一个`top`，返回栈顶元素，输入了一个指定混洗后序列。先顺序往栈中加入元素，直到栈顶元素为指定序列的第一个数，此时`pop`。继续顺序加入，直到栈顶元素为指定序列的第二个数，此时`pop`...如此循环，直到指定序列已经出现则成功，反之如果栈顶一直不为下一个指定数字则失败。

并且用数组储存`2n`次操作，如果成功则输出，如果失败则不输出。



## 灯塔

题目要求能够照亮彼此的灯塔对数量，要想满足能够照亮彼此即某一个灯塔的横纵坐标均小于另一个灯塔。

设计一种数据结构，包含灯塔的横、纵坐标，可以利用归并排序先按灯塔的横坐标从大到小顺序排序，然后再计算灯塔纵坐标的逆序对个数。这里的逆序对个数即能够照亮彼此的灯塔对数量。

