# OJ2 Report

## range Search

函数实现：归并排序，二分查找。

先对给定的$n$个数字序列进行归并排序，时间复杂度为$O(nlogn)$。查询的时候查到找不大于待查数字的最大值处，分别利用上下限查找序列，得到两个下标$left$和$right$，但是这里注意二分查找如果查找失败返回的是不大于待查数的最大秩。因此这里这只上限为给定的$b$，此时$right$所指的数必定是区间内的最大值，而下限选择用$a-1$，这样可以保证$left$所指的数一定是区间内最小的数的前一个，那么只需要将二者相减$right-left$就可以的到落在闭区间$[a, b]$的数字个数。

## tree Reconfiguration

真二叉树重构，给定先序遍历序列和后序遍历序列。

可以假设根节点为$P$，左右子树的根节点分别为$L,R$，观察发现前序遍历序列为$PL...R...$，而后序遍历序列为$...L...RP$，可以发现$P$节点的左右孩子即$L,R$，分别是其前序遍历序列的后一个元素和后序遍历序列的前一个元素。那么由此可以递归地构造出这颗真二叉树。

递归地构造二叉树，输入参数为原前序遍历和后序遍历的起始和终止位置，对应的部分就是以当前节点为根的子树的前序和后序遍历。最后仅需要使用中序遍历输出二叉树即可。

## game

在C球经过变化后，有以下两个条件：

1. 保证A球和B球数量相等。
2. 保证任意前k个球中， A球数量>=B球数量。

C球变化原则：

1. 变为A球时，尽量靠前；如果变为B球时，尽量靠后。
2. 假设A球比B球少k个， C球总共有M个：
   首先将前k个C球全部变为A球，保证A球和B球数量相等。 剩下的（M-k）个C球，前一半变为A球，后一半变为B球。如果M-k为奇数，则将中间的C球丢弃。
3. 如果A球比B球数量多k个：
   首先将最后k个C球全部变为B球，保证A球和B球数量相等。剩下的（M-k）个C球，前一半变为A球，后一半变为B球。如果M-k为奇数，则将中间的C球丢弃。

编程实现思想：

1. 从前到后遍历，A+C球个数大于等于B球个数。这样靠前的C球变成A球必然能满足条件2。但仍有可能使得最终A球多于B球。
2. 从后往前遍历，A球个数小于等于B+C球个数。这样靠后的C球变为B球必然可以满足条件1。

$A+C\ge B$

$A\le B+C$

